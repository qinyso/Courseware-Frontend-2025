# 蓝山工作室前端组Lesson6----javascript异步编程

JavaScript 的执行模型基于**单线程**，这意味着它在同一时间段内只能处理一个任务，就像一个人在厨房做饭，一次只能专注完成一个步骤。

如果采用同步方式处理所有操作，当遇到耗时任务（比如从服务器获取数据、读取本地文件、等待定时器结束）时，主线程必须暂停当前工作，等待耗时任务完成后才能继续下一步。这种情况下，前端页面会出现明显的卡顿 —— 用户点击按钮无响应、页面无法滚动、动画停止播放，因为主线程被耗时任务 “卡住” 了，无法处理用户交互和 UI 渲染等关键工作。

异步编程的核心目的，就是打破这种阻塞状态。它允许耗时任务脱离主线程在后台执行，主线程则可以继续处理优先级更高的任务（比如响应用户点击、更新页面元素）。当后台的耗时任务完成后，会通过特定机制（回调函数、Promise、async/await 等）通知主线程，主线程再在空闲时处理该任务的结果。



## 同步与异步

---

### 同步

JavaScript中的同步（Synchronous）指的是代码按照顺序逐行执行的方式。在同步代码中，每一行代码的执行都必须等待前一行代码执行完毕才能继续执行下一行代码，这意味着代码的执行是阻塞的，直到当前行的任务完成后才会执行下一行代码。

在同步代码中，如果遇到一个耗时的操作（如网络请求、文件读取、复杂计算等），代码会一直等待该操作完成后才会继续执行下一行代码。这可能导致页面或应用程序的阻塞，因为在等待耗时操作完成期间，JavaScript执行引擎无法执行其他任务，界面可能会冻结或不响应。

```javascript
console.log("开始");
console.log("执行任务1");
console.log("执行任务2");
console.log("结束");
```

在执行同步代码时，如果遇到一个耗时的操作，例如一个循环计算耗费较长的时间，那么代码会一直停留在这个循环中，直到循环计算完成才会继续执行后续代码。

同步代码的执行方式相对简单，因为代码按照顺序执行，开发者可以更容易地理解和控制代码的执行流程。然而，对于需要处理大量数据或耗时操作的情况，同步代码可能会导致性能问题和用户体验下降，因为页面或应用程序可能会在等待操作完成时出现卡顿或无响应的情况。

为了解决同步代码的阻塞问题，JavaScript提供了异步编程的机制，可以使用回调函数、Promise、async/await等方式来处理耗时操作，使得代码在等待操作完成期间可以执行其他任务，从而提高响应性和并发性。

### 异步

```javascript
console.log("开始")；
setTimeout(function(){
   consle.log("异步操作完成") 
},2000);
console.log（"结束"）
```

在这个示例中，使用了`setTimeout`函数来模拟一个异步操作，它会在2秒后触发回调函数。在执行过程中，代码不会等待`setTimeout`

```javascript
开始
结束
异步操作完成
```

在执行异步代码时，当遇到一个耗时的操作（如网络请求、文件读写、定时器等），代码会将该操作委托给其他机制处理，并立即继续执行后续代码。当操作完成后，会触发一个回调函数或返回一个Promise对象，以通知代码操作的完成。

-

<img title="" src="https://cdn.jsdelivr.net/gh/qinyso/pic-bed/20251125204653270.png" alt="">

## 任务队列与事件循环

---

### 宏任务

宏任务是指由 JavaScript 主线程执行的任务，它包括但不限于以下情况：

* **浏览器事件**（如 click、mouseover 等）

* **定时器任务**（如 setTimeout 和 setInterval）

* **页面渲染**（如 回流或重绘）

* **事件回调**（如 I/O、点击事件等）

* **网络请求** （如 XMLHttpRequest 和 fetch 等）
  示例1：用事件监听创建宏任务
  
  ```javascxript
  const button=document.querySelector("button");
  button.addEventListener("click",()=>{
      console.log("Button clicked");
  });
  
  console.log("Waiting for button click...");
  ```

    示例2： 使用定时器创建宏任务

```html
<!DOCTYPE html>
<html lang="en">
<head>
<body>
  <button id="btn">Click me</button>  
</body>
<script>
console.log("start");
setTimeout(()=>{
  console.log("In Timeout");
},2000);
console.log("end");
const button=document.querySelector('#btn');
button.addEventListener('click',()=>{
  console.log("Button Clicked")
});
console.log("Waiting for Button onclick")
</script>
</html>
```

示例3：页面渲染

```javascript
console.log("Start");

// 修改页面样式
document.body.style.backgroundColor = "red";

console.log("End"); 
```

> 总结： 宏任务的使用广泛，包括定时器任务、网络请求、事件监听器等。理解宏任务的概念和用法可以帮助我们正确处理 JavaScript 中的异步操作，并合理安排任务的执行顺序，以提高应用的性能和用户体验。

### 微任务

微任务是 JavaScript 事件循环中优先级**高于宏任务**的异步任务类型，用于处理需要**尽快执行**的异步操作（通常是 Promise 相关回调），其执行时机严格遵循 “同步代码执行完毕后立即清空微任务队列” 的规则。

* Promise 的回调函数
* Async/Await 函数
* MutationObserver 的回调函数
* process.nextTick（Node.js 环境下）
  
  

```html
<!DOCTYPE html>
<html lang="en">
<head>
<body>

</body>
<script>
console.log("同步代码");
setTimeout(()=>{
  console.log('宏任务(setTimeout)');
},0)
Promise.resolve().then(()=>{
  console.log('微任务(promise)');
});
</script>
</html>
```

### 事件循环

事件循环是一个持续运行的循环，它不断地从任务队列中获取任务并执行。事件循环的运行过程如下：

1. 从宏任务队列中取出一个任务执行。
2. 执行过程中，如果遇到微任务，将其添加到微任务队列中。
3. 当前宏任务执行完毕后，检查微任务队列，依次执行所有微任务。
4. 检查是否需要渲染页面的更新。
5. 执行下一个宏任务（从宏任务队列中取出）。
6. 重复上述步骤，循环执行。

<img title="" src="https://cdn.jsdelivr.net/gh/qinyso/pic-bed/20251127163543362.png" alt="">

这个过程保证了任务的执行顺序和异步代码的管理。通过将任务按照宏任务和微任务的方式添加到队列中，并通过事件循环的机制来执行任务，JavaScript能够实现高效的异步编程和处理。

需要注意的是，微任务在每个宏任务执行完毕后立即执行，而不是等待所有的宏任务执行完毕。这意味着微任务能够在同一轮事件循环中快速执行，而不需要等待下一轮事件循环。

任务队列和事件循环机制是 JavaScript 异步编程的核心概念，理解它们能够帮助开发者更好地处理异步代码的执行顺序和控制程序的流程。
常见的异步形式

-------

---



### 回调函数

回调函数是一种传递给异步函数的函数，在异步操作完成后被调用。通过将回调函数作为参数传递给异步函数，可以在异步操作完成后执行相应的处理逻辑。

#### 1.定时器回调函数

在使用`setTimeout`或`setInterval`函数创建定时器时，可以传递一个回调函数作为参数，用于指定需要在一定时间后执行的操作。

```javascript
setTimeout(function(){
    console.log("定时器回调函数")
},1000);
```

#### 2.事件处理回调函数

在处理DOM事件或其他异步事件时，通常需要指定一个回调函数来处理事件触发时的操作。

```javascript
document.addEventListener("click", function () {
  console.log("点击事件回调函数");
});
```

#### .AJAX回调函数

在进行异步请求（如通过XMLHttpRequest或fetch发送请求）时，可以指定回调函数来处理响应结果。

```javascript
fetch("https://api.example.com/data")
  .then(function (response) {
    return response.json();
  })
  .then(function (data) {
    console.log("AJAX回调函数", data);
  });
```

### 回调地狱

回调地狱（Callback Hell）是指在异步编程中，多个嵌套的回调函数形成的复杂和难以维护的代码结构。当有多个异步操作需要依次执行，并且后一个操作依赖于前一个操作的结果时，代码会出现深层嵌套的回调函数，导致代码可读性差、难以理解和调试。

以下是一个典型的回调地狱示例：

```javascript
asyncFunc1(function (result1) {
  asyncFunc2(result1, function (result2) {
    asyncFunc3(result2, function (result3) {
      asyncFunc4(result3, function (result4) {
        // 更多回调函数...
      });
    });
  });
});

```

这种嵌套回调的代码结构使得代码难以理解，可读性差，同时也增加了出错的可能性。当需要处理大量的异步操作时，回调地狱会导致代码的可维护性和可扩展性变差。

### Promise

在 JavaScript 中，Promise 是一种用于处理异步操作的对象。它表示一个异步操作的最终完成或失败，并提供了一种更优雅的方式来处理异步代码。

创建 Promise 对象可以使用 Promise 构造函数，它接受一个执行器函数作为参数。执行器函数会立即执行，通常包含异步操作，并决定 Promise 是成功还是失败。执行器函数带有两个参数，它们是 resolve 和 reject 函数，用于将 Promise 标记为成功或失败。

```javascript
new Promise((resolve, reject) => {
    console.log("Promise start")
    resolve('success')
})
console.log("End")

```

我们可以利用Promise的特性进行实例化

```js
const myPromise = new Promise(resolve => {
    setTimeout(() => { // 修正拼写
        console.log('执行完成');
        resolve('win'); // 标记Promise为成功状态，并传递结果
    }, 0); // 补充定时器延迟（可选，默认0）
});

myPromise.then(() => { // 移到外部，Promise实例化后调用
    console.log('Promise成功后的回调');
});
```


